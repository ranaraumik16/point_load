{"version":3,"sources":["../../../src/lib/parse-las.js"],"names":["parseLAS","arraybuffer","options","pointIndex","positions","colors","intensities","classifications","originalHeader","result","onProgress","las","skip","parseLASChunked","decoder","header","total","totalToRead","Float32Array","pointsFormatId","Uint8Array","Uint16Array","Object","assign","loaderData","mode","attributes","POSITION","value","size","intensity","classification","COLOR_0","batchSize","pointsCount","scale","scaleX","scaleY","scaleZ","offset","offsetX","offsetY","offsetZ","i","getPoint","position","color","vertexCount","totalRead","progress","boundingBox","rawData","onParseData","dataHandler","LASFile","open","getHeader","Unpacker","getUnpacker","Math","ceil","max","chunk","readData","count","versionAsString","isCompressed","unpacker","buffer","hasMoreData","e","close"],"mappings":"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","sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n// ported and es6-ified from https://github.com/verma/plasio/\nimport {LASFile} from './laslaz-decoder';\n\n/* eslint-disable max-statements */\nexport default function parseLAS(arraybuffer, options = {}) {\n  let pointIndex = 0;\n\n  let positions;\n  let colors;\n  let intensities;\n  let classifications;\n  let originalHeader;\n\n  const result = {};\n  const {onProgress} = options;\n  const {skip} = options.las || {};\n\n  parseLASChunked(arraybuffer, skip, (decoder, header) => {\n    if (!originalHeader) {\n      originalHeader = header;\n      const total = header.totalToRead;\n\n      positions = new Float32Array(total * 3);\n      // laslaz-decoder.js `pointFormatReaders`\n      colors = header.pointsFormatId >= 2 ? new Uint8Array(total * 4) : null;\n      intensities = new Uint16Array(total);\n      classifications = new Uint8Array(total);\n\n      Object.assign(result, {\n        loaderData: {header},\n        mode: 0, // GL.POINTS\n        attributes: {\n          POSITION: {value: positions, size: 3},\n          // non-gltf attributes, use non-capitalized names for now\n          intensity: {value: intensities, size: 1},\n          classification: {value: classifications, size: 1}\n        }\n      });\n\n      if (colors) {\n        result.attributes.COLOR_0 = {value: colors, size: 4};\n      }\n    }\n\n    const batchSize = decoder.pointsCount;\n    const {\n      scale: [scaleX, scaleY, scaleZ],\n      offset: [offsetX, offsetY, offsetZ]\n    } = header;\n\n    for (let i = 0; i < batchSize; i++) {\n      const {position, color, intensity, classification} = decoder.getPoint(i);\n\n      positions[pointIndex * 3] = position[0] * scaleX + offsetX;\n      positions[pointIndex * 3 + 1] = position[1] * scaleY + offsetY;\n      positions[pointIndex * 3 + 2] = position[2] * scaleZ + offsetZ;\n\n      if (color) {\n        colors[pointIndex * 4] = color[0];\n        colors[pointIndex * 4 + 1] = color[1];\n        colors[pointIndex * 4 + 2] = color[2];\n        colors[pointIndex * 4 + 3] = 255;\n      }\n\n      intensities[pointIndex] = intensity;\n      classifications[pointIndex] = classification;\n\n      pointIndex++;\n    }\n\n    if (onProgress) {\n      onProgress(\n        Object.assign(\n          {\n            header: {\n              vertexCount: header.totalRead\n            },\n            progress: header.totalRead / header.totalToRead\n          },\n          result\n        )\n      );\n    }\n  });\n\n  result.header = {\n    // @ts-ignore Possibly undefined\n    vertexCount: originalHeader.totalToRead,\n    boundingBox: getMeshBoundingBox(result.attributes)\n  };\n  return result;\n}\n/* eslint-enable max-statements */\n\n/**\n * parse laz data\n * @return {*} parsed point cloud\n */\nexport function parseLASChunked(rawData, skip, onParseData) {\n  const dataHandler = new LASFile(rawData);\n\n  try {\n    // open data\n    dataHandler.open();\n\n    const header = dataHandler.getHeader();\n    // start loading\n    const Unpacker = dataHandler.getUnpacker();\n\n    const totalToRead = Math.ceil(header.pointsCount / Math.max(1, skip));\n    header.totalToRead = totalToRead;\n    let totalRead = 0;\n\n    /* eslint-disable no-constant-condition */\n    while (true) {\n      const chunk = dataHandler.readData(1000 * 100, 0, skip);\n\n      totalRead += chunk.count;\n\n      header.totalRead = totalRead;\n      header.versionAsString = chunk.versionAsString;\n      header.isCompressed = chunk.isCompressed;\n\n      const unpacker = new Unpacker(chunk.buffer, chunk.count, header);\n\n      // surface unpacker and progress via call back\n      // use unpacker.pointsCount and unpacker.getPoint(i) to handle data in app\n      onParseData(unpacker, header);\n\n      if (!chunk.hasMoreData || totalRead >= totalToRead) {\n        break;\n      }\n    }\n  } catch (e) {\n    throw e;\n  } finally {\n    dataHandler.close();\n  }\n}\n"],"file":"parse-las.js"}